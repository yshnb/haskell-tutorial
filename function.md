# Haskellの基本: 関数

## 関数

いわゆるふつうの（関数型言語でない）プログラミング言語の関数とは、ちょっと違います。

普通のプログラミング言語における関数は一連の処理をまとめた「手続き (procedure) 」なのに対して、  
それに対してHaskellの関数は、入力が同じであれば出力も必ず同じになる、数学的な意味での「関数」となっています。


### 関数の使い方

関数は、 `<関数名> <値>` という形で引数をとります。  
後で説明しますが、Haskellの関数は複数の値をとることができません。

```
Prelude> sum [1 .. 5]
15
```

変数と型のところで、 `+` などの演算子も関数だということを紹介したので、次のように書けます。

```
Prelude> (+1) 1
2
Prelude> (+) 1 2
3
```

### 関数の定義

Haskellでの関数は、次のように定義します。

```
-- 1. 関数の引数と返り値の型（または型クラス）を定義する部分
functionName :: Num a => a -> a
-- 2. 引数に対する結果を定義する部分（パターンマッチ）
functionName x = x + 3
```

では、実際の関数の作り方を見てみましょう。  
以下のような[function.hs](examples/function.hs)というファイルを作ってください。  
（コメントの部分はお好きにどうぞ）

```
-- 簡単な関数定義

-- plusOneという名前の関数は、Num 型クラスの値aを使う。値aを引数にとり、同じNum 型クラスの値を返す。
-- plusOneが返す値は、引数xに対して+1した値
plusOne :: Num a => a -> a
plusOne x = x + 1

-- powerという名前の関数は、Integral 型クラスの値aとNum 型クラスの値bを使う。
-- Num 型クラスの値aをとり、さらにIntegral 型クラスの値bをとると、最終的に値aを返す。
-- powerは、Num 型クラスの引数xとIntegral 型クラスの引数yを使って、xをy乗した値を返す
power :: (Integral b, Num a) => a -> b -> a
power x y = x ^ y
```

保存したら、 `:load function.hs` としてみましょう。  
うまくいけば次のようになるはずです。

```
Prelude> :load function.hs
[1 of 1] Compiling Main             ( function.hs, interpreted )
Ok, modules loaded: Main.
*Main>
```

`plusOne` という関数を定義したので、実行してみましょう。

```
*Main> plusOne 1
2
```

値が +1 されていますね。

同じように、powerについても次のように使用できます。

```
*Main> power 10 2
100
```

### パターンマッチを使った関数定義

パターンマッチとは、入力となる引数の値がマッチすれば、その右側に記述した値や計算結果を返すというものです。

パターンマッチを使った関数定義の例をみてみましょう。

```
-- ゼロかどうかを返す関数
-- Eq クラスかつNum クラスの値をaとして、aを引数にとりBoolを返す関数
-- 引数が0ならTrueを、それ以外の値ならFalseを返す。
isZero :: (Eq a, Num a) => a -> Bool
isZero 0 = True
isZero _ = False
```

この例では最初に型を定義した後で、次のように２つのパターンを与えています。

```
isZero 0 = True
isZero _ = False
```

パターンは上から順に評価されるので、  
関数の引数として0を入力した場合には `0 =` にマッチ  
一方それ以外の値を入力した場合は、任意の値を表す _ = にマッチするので、`False` という値が返されます。  


### ガードを使った形式の例

パターンマッチほど特徴的ではありませんが、ガードについても見てみましょう。

```
-- 絶対値を返す関数
-- Ord クラスかつNum クラスの値をaとして、aを引数にとりaを返す関数
-- 引数nが0以上ならnを返す。nが0以下なら-nを返す
myAbs :: (Ord a, Num a) => a -> a
myAbs n
  | n >= 0 = n
  | n < 0  = -n
```

（もう少し書く）

### その他の例
もう少し複雑な例として、有名なクイックソートの例を見てみましょう。

```
-- Haskellのクイックソート（有名な例）
-- Ord クラスの値をaとして、aのリストを引数にとりaのリストを返す（ソートするだけなので当然！）
qsort :: Ord a => [a] -> [a]

-- リストが空の場合にマッチ。空の値を返す。
qsort [] = []

-- リストを先頭の値xとそれ以降のリストに分割することができる（＝リストの値が存在する）場合にマッチ。
-- リストを「xより小さい値のリストをqsortしたリスト」「xだけのリスト」「xより大きい値のリストをqsortしたリスト」に分割して
-- 上述の順番で結合したリストを返す。
qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger
  where
    smaller = [a | a <- xs, a <= x]
    larger  = [b | b <- xs, b > x]
```

`where` は関数の中で使うための表現を定義する仕組みです。

## 関数も値である

Haskellには、関数も値として扱うことができます。

例えば、 `(+1)` という関数は、値を入力すると1が加算された値を返す関数です。  
これを値として変数に束縛することができます。

```
Prelude> let plusOne = (+1)
Prelude> pludOne 1
2
```

最近は、ほとんどの言語でこのようなことが可能になっていますが、  
この性質は第一級関数などと呼ばれます。

## ラムダ式

Haskellの関数定義の方法は、次のような方法でした。

通常の定義の方法としては、例えば[このような](examples/function_not_lambda.hs)定義になります。
```
-- 引数と返り値の型
anyTimeFalse :: a -> Bool

-- パターンマッチ
anyTimeFalse _ = False
```

`anyTimeFalse` は、任意の型の値を１つ受け取り `False` を返す関数です。

ラムダ式を使うと、これを次のように定義できます。

```
\x -> False
```

先ほど説明したように、関数は値として扱うことができるので、

```
Prelude> let anyTimeFalse = \x -> False
Prelude> anyTimeFalse "1"
False
```

上記のように動作することがわかります。


ラムダ式の基礎となるラムダ計算にはまた別の意味があるのですが、
使う分にはこのような形で特別な名前を定義せずとも使える関数だと認識しておけば十分です。


